"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/my-reviews/page",{

/***/ "(app-pages-browser)/./lib/firestore.ts":
/*!**************************!*\
  !*** ./lib/firestore.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createReview: function() { return /* binding */ createReview; },\n/* harmony export */   createService: function() { return /* binding */ createService; },\n/* harmony export */   deleteReview: function() { return /* binding */ deleteReview; },\n/* harmony export */   getPendingReviews: function() { return /* binding */ getPendingReviews; },\n/* harmony export */   getPendingServices: function() { return /* binding */ getPendingServices; },\n/* harmony export */   getReviewById: function() { return /* binding */ getReviewById; },\n/* harmony export */   getReviewsByServiceId: function() { return /* binding */ getReviewsByServiceId; },\n/* harmony export */   getReviewsByUserId: function() { return /* binding */ getReviewsByUserId; },\n/* harmony export */   getServiceById: function() { return /* binding */ getServiceById; },\n/* harmony export */   getServices: function() { return /* binding */ getServices; },\n/* harmony export */   searchServices: function() { return /* binding */ searchServices; },\n/* harmony export */   updateReview: function() { return /* binding */ updateReview; },\n/* harmony export */   updateReviewStatus: function() { return /* binding */ updateReviewStatus; },\n/* harmony export */   updateServiceRating: function() { return /* binding */ updateServiceRating; },\n/* harmony export */   updateServiceStatus: function() { return /* binding */ updateServiceStatus; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/storage */ \"(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n\n\n\n\n// Get all services\nconst getServices = async function() {\n    let includePending = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    const servicesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"services\");\n    const constraints = [];\n    if (!includePending) {\n        // Only get approved services by default\n        constraints.push((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"pending\", \"==\", false));\n    }\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(servicesCollection, ...constraints, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"name\"));\n    const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n    return snapshot.docs.map((doc)=>{\n        return {\n            id: doc.id,\n            ...doc.data()\n        };\n    });\n};\n// Get service by ID\nconst getServiceById = async (id)=>{\n    const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"services\", id);\n    const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(docRef);\n    if (docSnap.exists()) {\n        return {\n            id: docSnap.id,\n            ...docSnap.data()\n        };\n    }\n    return null;\n};\n// Get reviews for a service\nconst getReviewsByServiceId = async function(serviceId) {\n    let showPending = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const reviewsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"reviews\");\n    // Only show approved reviews unless showPending is true\n    const constraints = [\n        (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"serviceId\", \"==\", serviceId)\n    ];\n    if (!showPending) {\n        constraints.push((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"pending\", \"==\", false));\n    }\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(reviewsCollection, ...constraints, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n    const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n    return snapshot.docs.map((doc)=>{\n        return {\n            id: doc.id,\n            ...doc.data()\n        };\n    });\n};\n// Get all pending reviews (for admin)\nconst getPendingReviews = async ()=>{\n    const reviewsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"reviews\");\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(reviewsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"pending\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n    const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n    return snapshot.docs.map((doc)=>{\n        return {\n            id: doc.id,\n            ...doc.data()\n        };\n    });\n};\n// Create a new review\nconst createReview = async (review, imageFile)=>{\n    // Prepare review data\n    const reviewData = {\n        ...review,\n        pending: true,\n        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n    };\n    // Upload image if provided\n    if (imageFile) {\n        const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, \"reviews/\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()));\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.uploadBytes)(imageRef, imageFile);\n        reviewData.imageUrl = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.getDownloadURL)(imageRef);\n    }\n    // Add review to Firestore\n    const reviewRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"reviews\"), reviewData);\n    return reviewRef.id;\n};\n// Approve or reject a review\nconst updateReviewStatus = async (reviewId, approve)=>{\n    const reviewRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"reviews\", reviewId);\n    const reviewSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(reviewRef);\n    if (!reviewSnap.exists()) {\n        throw new Error(\"Review does not exist\");\n    }\n    const review = reviewSnap.data();\n    if (approve) {\n        // Approve the review\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(reviewRef, {\n            pending: false\n        });\n        // Update service rating\n        await updateServiceRating(review.serviceId);\n    } else {\n        // Delete the review if not approved\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)(reviewRef);\n    }\n};\n// Update service rating based on approved reviews\nconst updateServiceRating = async (serviceId)=>{\n    const approvedReviews = await getReviewsByServiceId(serviceId);\n    if (approvedReviews.length === 0) return;\n    // Calculate average rating\n    const totalRating = approvedReviews.reduce((sum, review)=>sum + review.rating, 0);\n    const averageRating = totalRating / approvedReviews.length;\n    // Update service document\n    const serviceRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"services\", serviceId);\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(serviceRef, {\n        averageRating,\n        reviewCount: approvedReviews.length\n    });\n};\n// Add this new function to create a service\nconst createService = async (serviceData, imageFile)=>{\n    // Prepare service data with default values\n    const newService = {\n        ...serviceData,\n        averageRating: 0,\n        reviewCount: 0,\n        pending: true,\n        createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n    };\n    // Upload image if provided\n    if (imageFile) {\n        const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, \"services/\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()));\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.uploadBytes)(imageRef, imageFile);\n        newService.imageUrl = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.getDownloadURL)(imageRef);\n    }\n    // Add service to Firestore\n    const serviceRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"services\"), newService);\n    return serviceRef.id;\n};\n// Add this new function to search services\nconst searchServices = async (searchTerm)=>{\n    if (!searchTerm.trim()) {\n        return getServices(); // Return all approved services if search term is empty\n    }\n    const searchTermLower = searchTerm.toLowerCase();\n    // Get all approved services first\n    const servicesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"services\");\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(servicesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"pending\", \"==\", false));\n    const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n    // Filter the services client-side based ONLY on the service name\n    const filteredServices = snapshot.docs.map((doc)=>({\n            id: doc.id,\n            ...doc.data()\n        })).filter((service)=>service.name.toLowerCase().includes(searchTermLower));\n    return filteredServices;\n};\n// Get pending services (for admin)\nconst getPendingServices = async ()=>{\n    const servicesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"services\");\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(servicesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"pending\", \"==\", true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n    const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n    return snapshot.docs.map((doc)=>{\n        return {\n            id: doc.id,\n            ...doc.data()\n        };\n    });\n};\n// Approve or reject a pending service\nconst updateServiceStatus = async (serviceId, approve)=>{\n    const serviceRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"services\", serviceId);\n    const serviceSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(serviceRef);\n    if (!serviceSnap.exists()) {\n        throw new Error(\"Service does not exist\");\n    }\n    if (approve) {\n        // Approve the service\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(serviceRef, {\n            pending: false\n        });\n    } else {\n        // Delete the service if not approved\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)(serviceRef);\n    }\n};\n// Get reviews by user ID (for My Reviews page)\nconst getReviewsByUserId = async (userId)=>{\n    const reviewsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"reviews\");\n    const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)(reviewsCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n    const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n    return snapshot.docs.map((doc)=>{\n        return {\n            id: doc.id,\n            ...doc.data()\n        };\n    });\n};\n// Update a review\nconst updateReview = async (reviewId, reviewData, imageFile)=>{\n    const reviewRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"reviews\", reviewId);\n    const reviewSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(reviewRef);\n    if (!reviewSnap.exists()) {\n        throw new Error(\"Review does not exist\");\n    }\n    // Prepare updated data\n    const updateData = {\n        ...reviewData\n    };\n    // Remove the imageUrl if it's 'pending-upload' as we'll replace it\n    if (updateData.imageUrl === \"pending-upload\") {\n        delete updateData.imageUrl;\n    }\n    // Upload image if provided\n    if (imageFile) {\n        const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, \"reviews/\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()));\n        await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.uploadBytes)(imageRef, imageFile);\n        updateData.imageUrl = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.getDownloadURL)(imageRef);\n    }\n    // Update review with new data\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(reviewRef, {\n        ...updateData,\n        // Reviews that are edited need to be approved again\n        pending: true\n    });\n    // Get the review after update to access the serviceId\n    const updatedReviewSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(reviewRef);\n    const updatedReview = updatedReviewSnap.data();\n    // Update service rating after a review is updated\n    await updateServiceRating(updatedReview.serviceId);\n};\n// Delete a review\nconst deleteReview = async (reviewId)=>{\n    const reviewRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"reviews\", reviewId);\n    const reviewSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(reviewRef);\n    if (!reviewSnap.exists()) {\n        throw new Error(\"Review does not exist\");\n    }\n    const review = reviewSnap.data();\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)(reviewRef);\n    // Update service rating after a review is deleted\n    await updateServiceRating(review.serviceId);\n};\n// Get a single review by ID\nconst getReviewById = async (reviewId)=>{\n    const reviewRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, \"reviews\", reviewId);\n    const reviewSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(reviewRef);\n    if (!reviewSnap.exists()) {\n        return null;\n    }\n    return {\n        id: reviewId,\n        ...reviewSnap.data()\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RHZDLFNBQVM7SUFDWDtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNd0Msb0JBQW9CLE1BQU1oRiwwREFBTUEsQ0FBQzRDO0lBQ3ZDLE1BQU1xQyxnQkFBZ0JELGtCQUFrQnRELElBQUk7SUFFNUMsa0RBQWtEO0lBQ2xELE1BQU13QixvQkFBb0IrQixjQUFjakQsU0FBUztBQUNuRCxFQUFFO0FBRUYsa0JBQWtCO0FBQ1gsTUFBTWtELGVBQWUsT0FBT3BDO0lBQ2pDLE1BQU1GLFlBQVk3Qyx1REFBR0EsQ0FBQ2UseUNBQUVBLEVBQUUsV0FBV2dDO0lBQ3JDLE1BQU1FLGFBQWEsTUFBTWhELDBEQUFNQSxDQUFDNEM7SUFFaEMsSUFBSSxDQUFDSSxXQUFXbEIsTUFBTSxJQUFJO1FBQ3hCLE1BQU0sSUFBSW1CLE1BQU07SUFDbEI7SUFFQSxNQUFNWixTQUFTVyxXQUFXdEIsSUFBSTtJQUM5QixNQUFNdkIsNkRBQVNBLENBQUN5QztJQUVoQixrREFBa0Q7SUFDbEQsTUFBTU0sb0JBQW9CYixPQUFPTCxTQUFTO0FBQzVDLEVBQUU7QUFFRiw0QkFBNEI7QUFDckIsTUFBTW1ELGdCQUFnQixPQUMzQnJDO0lBRUEsTUFBTUYsWUFBWTdDLHVEQUFHQSxDQUFDZSx5Q0FBRUEsRUFBRSxXQUFXZ0M7SUFDckMsTUFBTUUsYUFBYSxNQUFNaEQsMERBQU1BLENBQUM0QztJQUVoQyxJQUFJLENBQUNJLFdBQVdsQixNQUFNLElBQUk7UUFDeEIsT0FBTztJQUNUO0lBRUEsT0FBTztRQUFFTCxJQUFJcUI7UUFBVSxHQUFHRSxXQUFXdEIsSUFBSSxFQUFFO0lBQUM7QUFDOUMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZmlyZXN0b3JlLnRzP2I0NmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgY29sbGVjdGlvbixcbiAgZG9jLFxuICBnZXREb2MsXG4gIGdldERvY3MsXG4gIHNldERvYyxcbiAgdXBkYXRlRG9jLFxuICBkZWxldGVEb2MsXG4gIHF1ZXJ5LFxuICB3aGVyZSxcbiAgb3JkZXJCeSxcbiAgbGltaXQsXG4gIHNlcnZlclRpbWVzdGFtcCxcbiAgVGltZXN0YW1wLFxuICBhZGREb2MsXG4gIERvY3VtZW50UmVmZXJlbmNlLFxufSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHsgcmVmLCB1cGxvYWRCeXRlcywgZ2V0RG93bmxvYWRVUkwgfSBmcm9tICdmaXJlYmFzZS9zdG9yYWdlJztcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgZGIsIHN0b3JhZ2UgfSBmcm9tICcuL2ZpcmViYXNlJztcblxuLy8gU2VydmljZSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZSB7XG4gIGlkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGxvY2F0aW9uOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGltYWdlVXJsPzogc3RyaW5nO1xuICBhdmVyYWdlUmF0aW5nPzogbnVtYmVyO1xuICByZXZpZXdDb3VudD86IG51bWJlcjtcbiAgY3JlYXRlZEF0PzogVGltZXN0YW1wO1xuICBwZW5kaW5nPzogYm9vbGVhbjtcbiAgdXNlcklkPzogc3RyaW5nO1xufVxuXG4vLyBSZXZpZXcgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFJldmlldyB7XG4gIGlkPzogc3RyaW5nO1xuICBzZXJ2aWNlSWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIHVzZXJFbWFpbDogc3RyaW5nO1xuICByYXRpbmc6IG51bWJlcjtcbiAgY29tbWVudDogc3RyaW5nO1xuICBpbWFnZVVybD86IHN0cmluZztcbiAgcGVuZGluZzogYm9vbGVhbjtcbiAgY3JlYXRlZEF0PzogVGltZXN0YW1wO1xufVxuXG4vLyBHZXQgYWxsIHNlcnZpY2VzXG5leHBvcnQgY29uc3QgZ2V0U2VydmljZXMgPSBhc3luYyAoXG4gIGluY2x1ZGVQZW5kaW5nOiBib29sZWFuID0gZmFsc2Vcbik6IFByb21pc2U8U2VydmljZVtdPiA9PiB7XG4gIGNvbnN0IHNlcnZpY2VzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdzZXJ2aWNlcycpO1xuICBjb25zdCBjb25zdHJhaW50cyA9IFtdO1xuXG4gIGlmICghaW5jbHVkZVBlbmRpbmcpIHtcbiAgICAvLyBPbmx5IGdldCBhcHByb3ZlZCBzZXJ2aWNlcyBieSBkZWZhdWx0XG4gICAgY29uc3RyYWludHMucHVzaCh3aGVyZSgncGVuZGluZycsICc9PScsIGZhbHNlKSk7XG4gIH1cblxuICBjb25zdCBxID0gcXVlcnkoc2VydmljZXNDb2xsZWN0aW9uLCAuLi5jb25zdHJhaW50cywgb3JkZXJCeSgnbmFtZScpKTtcbiAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuXG4gIHJldHVybiBzbmFwc2hvdC5kb2NzLm1hcCgoZG9jKSA9PiB7XG4gICAgcmV0dXJuIHsgaWQ6IGRvYy5pZCwgLi4uZG9jLmRhdGEoKSB9IGFzIFNlcnZpY2U7XG4gIH0pO1xufTtcblxuLy8gR2V0IHNlcnZpY2UgYnkgSURcbmV4cG9ydCBjb25zdCBnZXRTZXJ2aWNlQnlJZCA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTxTZXJ2aWNlIHwgbnVsbD4gPT4ge1xuICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsICdzZXJ2aWNlcycsIGlkKTtcbiAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xuXG4gIGlmIChkb2NTbmFwLmV4aXN0cygpKSB7XG4gICAgcmV0dXJuIHsgaWQ6IGRvY1NuYXAuaWQsIC4uLmRvY1NuYXAuZGF0YSgpIH0gYXMgU2VydmljZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gR2V0IHJldmlld3MgZm9yIGEgc2VydmljZVxuZXhwb3J0IGNvbnN0IGdldFJldmlld3NCeVNlcnZpY2VJZCA9IGFzeW5jIChcbiAgc2VydmljZUlkOiBzdHJpbmcsXG4gIHNob3dQZW5kaW5nOiBib29sZWFuID0gZmFsc2Vcbik6IFByb21pc2U8UmV2aWV3W10+ID0+IHtcbiAgY29uc3QgcmV2aWV3c0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uKGRiLCAncmV2aWV3cycpO1xuXG4gIC8vIE9ubHkgc2hvdyBhcHByb3ZlZCByZXZpZXdzIHVubGVzcyBzaG93UGVuZGluZyBpcyB0cnVlXG4gIGNvbnN0IGNvbnN0cmFpbnRzID0gW3doZXJlKCdzZXJ2aWNlSWQnLCAnPT0nLCBzZXJ2aWNlSWQpXTtcbiAgaWYgKCFzaG93UGVuZGluZykge1xuICAgIGNvbnN0cmFpbnRzLnB1c2god2hlcmUoJ3BlbmRpbmcnLCAnPT0nLCBmYWxzZSkpO1xuICB9XG5cbiAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgIHJldmlld3NDb2xsZWN0aW9uLFxuICAgIC4uLmNvbnN0cmFpbnRzLFxuICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJylcbiAgKTtcblxuICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG5cbiAgcmV0dXJuIHNuYXBzaG90LmRvY3MubWFwKChkb2MpID0+IHtcbiAgICByZXR1cm4geyBpZDogZG9jLmlkLCAuLi5kb2MuZGF0YSgpIH0gYXMgUmV2aWV3O1xuICB9KTtcbn07XG5cbi8vIEdldCBhbGwgcGVuZGluZyByZXZpZXdzIChmb3IgYWRtaW4pXG5leHBvcnQgY29uc3QgZ2V0UGVuZGluZ1Jldmlld3MgPSBhc3luYyAoKTogUHJvbWlzZTxSZXZpZXdbXT4gPT4ge1xuICBjb25zdCByZXZpZXdzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdyZXZpZXdzJyk7XG4gIGNvbnN0IHEgPSBxdWVyeShcbiAgICByZXZpZXdzQ29sbGVjdGlvbixcbiAgICB3aGVyZSgncGVuZGluZycsICc9PScsIHRydWUpLFxuICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJylcbiAgKTtcblxuICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG5cbiAgcmV0dXJuIHNuYXBzaG90LmRvY3MubWFwKChkb2MpID0+IHtcbiAgICByZXR1cm4geyBpZDogZG9jLmlkLCAuLi5kb2MuZGF0YSgpIH0gYXMgUmV2aWV3O1xuICB9KTtcbn07XG5cbi8vIENyZWF0ZSBhIG5ldyByZXZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVSZXZpZXcgPSBhc3luYyAoXG4gIHJldmlldzogT21pdDxSZXZpZXcsICdpZCcgfCAnY3JlYXRlZEF0JyB8ICdwZW5kaW5nJz4sXG4gIGltYWdlRmlsZT86IEZpbGVcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIC8vIFByZXBhcmUgcmV2aWV3IGRhdGFcbiAgY29uc3QgcmV2aWV3RGF0YTogT21pdDxSZXZpZXcsICdpZCc+ID0ge1xuICAgIC4uLnJldmlldyxcbiAgICBwZW5kaW5nOiB0cnVlLCAvLyBBbGwgcmV2aWV3cyBzdGFydCBhcyBwZW5kaW5nXG4gICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSBhcyBUaW1lc3RhbXAsXG4gIH07XG5cbiAgLy8gVXBsb2FkIGltYWdlIGlmIHByb3ZpZGVkXG4gIGlmIChpbWFnZUZpbGUpIHtcbiAgICBjb25zdCBpbWFnZVJlZiA9IHJlZihzdG9yYWdlLCBgcmV2aWV3cy8ke3V1aWR2NCgpfWApO1xuICAgIGF3YWl0IHVwbG9hZEJ5dGVzKGltYWdlUmVmLCBpbWFnZUZpbGUpO1xuICAgIHJldmlld0RhdGEuaW1hZ2VVcmwgPSBhd2FpdCBnZXREb3dubG9hZFVSTChpbWFnZVJlZik7XG4gIH1cblxuICAvLyBBZGQgcmV2aWV3IHRvIEZpcmVzdG9yZVxuICBjb25zdCByZXZpZXdSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ3Jldmlld3MnKSwgcmV2aWV3RGF0YSk7XG5cbiAgcmV0dXJuIHJldmlld1JlZi5pZDtcbn07XG5cbi8vIEFwcHJvdmUgb3IgcmVqZWN0IGEgcmV2aWV3XG5leHBvcnQgY29uc3QgdXBkYXRlUmV2aWV3U3RhdHVzID0gYXN5bmMgKFxuICByZXZpZXdJZDogc3RyaW5nLFxuICBhcHByb3ZlOiBib29sZWFuXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgcmV2aWV3UmVmID0gZG9jKGRiLCAncmV2aWV3cycsIHJldmlld0lkKTtcbiAgY29uc3QgcmV2aWV3U25hcCA9IGF3YWl0IGdldERvYyhyZXZpZXdSZWYpO1xuXG4gIGlmICghcmV2aWV3U25hcC5leGlzdHMoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmV2aWV3IGRvZXMgbm90IGV4aXN0Jyk7XG4gIH1cblxuICBjb25zdCByZXZpZXcgPSByZXZpZXdTbmFwLmRhdGEoKSBhcyBSZXZpZXc7XG5cbiAgaWYgKGFwcHJvdmUpIHtcbiAgICAvLyBBcHByb3ZlIHRoZSByZXZpZXdcbiAgICBhd2FpdCB1cGRhdGVEb2MocmV2aWV3UmVmLCB7IHBlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgLy8gVXBkYXRlIHNlcnZpY2UgcmF0aW5nXG4gICAgYXdhaXQgdXBkYXRlU2VydmljZVJhdGluZyhyZXZpZXcuc2VydmljZUlkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWxldGUgdGhlIHJldmlldyBpZiBub3QgYXBwcm92ZWRcbiAgICBhd2FpdCBkZWxldGVEb2MocmV2aWV3UmVmKTtcbiAgfVxufTtcblxuLy8gVXBkYXRlIHNlcnZpY2UgcmF0aW5nIGJhc2VkIG9uIGFwcHJvdmVkIHJldmlld3NcbmV4cG9ydCBjb25zdCB1cGRhdGVTZXJ2aWNlUmF0aW5nID0gYXN5bmMgKHNlcnZpY2VJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IGFwcHJvdmVkUmV2aWV3cyA9IGF3YWl0IGdldFJldmlld3NCeVNlcnZpY2VJZChzZXJ2aWNlSWQpO1xuXG4gIGlmIChhcHByb3ZlZFJldmlld3MubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgcmF0aW5nXG4gIGNvbnN0IHRvdGFsUmF0aW5nID0gYXBwcm92ZWRSZXZpZXdzLnJlZHVjZShcbiAgICAoc3VtLCByZXZpZXcpID0+IHN1bSArIHJldmlldy5yYXRpbmcsXG4gICAgMFxuICApO1xuICBjb25zdCBhdmVyYWdlUmF0aW5nID0gdG90YWxSYXRpbmcgLyBhcHByb3ZlZFJldmlld3MubGVuZ3RoO1xuXG4gIC8vIFVwZGF0ZSBzZXJ2aWNlIGRvY3VtZW50XG4gIGNvbnN0IHNlcnZpY2VSZWYgPSBkb2MoZGIsICdzZXJ2aWNlcycsIHNlcnZpY2VJZCk7XG4gIGF3YWl0IHVwZGF0ZURvYyhzZXJ2aWNlUmVmLCB7XG4gICAgYXZlcmFnZVJhdGluZyxcbiAgICByZXZpZXdDb3VudDogYXBwcm92ZWRSZXZpZXdzLmxlbmd0aCxcbiAgfSk7XG59O1xuXG4vLyBBZGQgdGhpcyBuZXcgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2VydmljZVxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlcnZpY2UgPSBhc3luYyAoXG4gIHNlcnZpY2VEYXRhOiBPbWl0PFxuICAgIFNlcnZpY2UsXG4gICAgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ2F2ZXJhZ2VSYXRpbmcnIHwgJ3Jldmlld0NvdW50JyB8ICdwZW5kaW5nJ1xuICA+LFxuICBpbWFnZUZpbGU/OiBGaWxlXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAvLyBQcmVwYXJlIHNlcnZpY2UgZGF0YSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gIGNvbnN0IG5ld1NlcnZpY2U6IE9taXQ8U2VydmljZSwgJ2lkJz4gPSB7XG4gICAgLi4uc2VydmljZURhdGEsXG4gICAgYXZlcmFnZVJhdGluZzogMCxcbiAgICByZXZpZXdDb3VudDogMCxcbiAgICBwZW5kaW5nOiB0cnVlLCAvLyBOZXcgc2VydmljZXMgYXJlIHBlbmRpbmcgYnkgZGVmYXVsdFxuICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCkgYXMgVGltZXN0YW1wLFxuICB9O1xuXG4gIC8vIFVwbG9hZCBpbWFnZSBpZiBwcm92aWRlZFxuICBpZiAoaW1hZ2VGaWxlKSB7XG4gICAgY29uc3QgaW1hZ2VSZWYgPSByZWYoc3RvcmFnZSwgYHNlcnZpY2VzLyR7dXVpZHY0KCl9YCk7XG4gICAgYXdhaXQgdXBsb2FkQnl0ZXMoaW1hZ2VSZWYsIGltYWdlRmlsZSk7XG4gICAgbmV3U2VydmljZS5pbWFnZVVybCA9IGF3YWl0IGdldERvd25sb2FkVVJMKGltYWdlUmVmKTtcbiAgfVxuXG4gIC8vIEFkZCBzZXJ2aWNlIHRvIEZpcmVzdG9yZVxuICBjb25zdCBzZXJ2aWNlUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdzZXJ2aWNlcycpLCBuZXdTZXJ2aWNlKTtcblxuICByZXR1cm4gc2VydmljZVJlZi5pZDtcbn07XG5cbi8vIEFkZCB0aGlzIG5ldyBmdW5jdGlvbiB0byBzZWFyY2ggc2VydmljZXNcbmV4cG9ydCBjb25zdCBzZWFyY2hTZXJ2aWNlcyA9IGFzeW5jIChcbiAgc2VhcmNoVGVybTogc3RyaW5nXG4pOiBQcm9taXNlPFNlcnZpY2VbXT4gPT4ge1xuICBpZiAoIXNlYXJjaFRlcm0udHJpbSgpKSB7XG4gICAgcmV0dXJuIGdldFNlcnZpY2VzKCk7IC8vIFJldHVybiBhbGwgYXBwcm92ZWQgc2VydmljZXMgaWYgc2VhcmNoIHRlcm0gaXMgZW1wdHlcbiAgfVxuXG4gIGNvbnN0IHNlYXJjaFRlcm1Mb3dlciA9IHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKTtcblxuICAvLyBHZXQgYWxsIGFwcHJvdmVkIHNlcnZpY2VzIGZpcnN0XG4gIGNvbnN0IHNlcnZpY2VzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdzZXJ2aWNlcycpO1xuICBjb25zdCBxID0gcXVlcnkoc2VydmljZXNDb2xsZWN0aW9uLCB3aGVyZSgncGVuZGluZycsICc9PScsIGZhbHNlKSk7XG4gIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcblxuICAvLyBGaWx0ZXIgdGhlIHNlcnZpY2VzIGNsaWVudC1zaWRlIGJhc2VkIE9OTFkgb24gdGhlIHNlcnZpY2UgbmFtZVxuICBjb25zdCBmaWx0ZXJlZFNlcnZpY2VzID0gc25hcHNob3QuZG9jc1xuICAgIC5tYXAoKGRvYykgPT4gKHsgaWQ6IGRvYy5pZCwgLi4uZG9jLmRhdGEoKSB9IGFzIFNlcnZpY2UpKVxuICAgIC5maWx0ZXIoKHNlcnZpY2UpID0+IHNlcnZpY2UubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm1Mb3dlcikpO1xuXG4gIHJldHVybiBmaWx0ZXJlZFNlcnZpY2VzO1xufTtcblxuLy8gR2V0IHBlbmRpbmcgc2VydmljZXMgKGZvciBhZG1pbilcbmV4cG9ydCBjb25zdCBnZXRQZW5kaW5nU2VydmljZXMgPSBhc3luYyAoKTogUHJvbWlzZTxTZXJ2aWNlW10+ID0+IHtcbiAgY29uc3Qgc2VydmljZXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ3NlcnZpY2VzJyk7XG4gIGNvbnN0IHEgPSBxdWVyeShcbiAgICBzZXJ2aWNlc0NvbGxlY3Rpb24sXG4gICAgd2hlcmUoJ3BlbmRpbmcnLCAnPT0nLCB0cnVlKSxcbiAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICk7XG5cbiAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuXG4gIHJldHVybiBzbmFwc2hvdC5kb2NzLm1hcCgoZG9jKSA9PiB7XG4gICAgcmV0dXJuIHsgaWQ6IGRvYy5pZCwgLi4uZG9jLmRhdGEoKSB9IGFzIFNlcnZpY2U7XG4gIH0pO1xufTtcblxuLy8gQXBwcm92ZSBvciByZWplY3QgYSBwZW5kaW5nIHNlcnZpY2VcbmV4cG9ydCBjb25zdCB1cGRhdGVTZXJ2aWNlU3RhdHVzID0gYXN5bmMgKFxuICBzZXJ2aWNlSWQ6IHN0cmluZyxcbiAgYXBwcm92ZTogYm9vbGVhblxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IHNlcnZpY2VSZWYgPSBkb2MoZGIsICdzZXJ2aWNlcycsIHNlcnZpY2VJZCk7XG4gIGNvbnN0IHNlcnZpY2VTbmFwID0gYXdhaXQgZ2V0RG9jKHNlcnZpY2VSZWYpO1xuXG4gIGlmICghc2VydmljZVNuYXAuZXhpc3RzKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZpY2UgZG9lcyBub3QgZXhpc3QnKTtcbiAgfVxuXG4gIGlmIChhcHByb3ZlKSB7XG4gICAgLy8gQXBwcm92ZSB0aGUgc2VydmljZVxuICAgIGF3YWl0IHVwZGF0ZURvYyhzZXJ2aWNlUmVmLCB7IHBlbmRpbmc6IGZhbHNlIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIERlbGV0ZSB0aGUgc2VydmljZSBpZiBub3QgYXBwcm92ZWRcbiAgICBhd2FpdCBkZWxldGVEb2Moc2VydmljZVJlZik7XG4gIH1cbn07XG5cbi8vIEdldCByZXZpZXdzIGJ5IHVzZXIgSUQgKGZvciBNeSBSZXZpZXdzIHBhZ2UpXG5leHBvcnQgY29uc3QgZ2V0UmV2aWV3c0J5VXNlcklkID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxSZXZpZXdbXT4gPT4ge1xuICBjb25zdCByZXZpZXdzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdyZXZpZXdzJyk7XG4gIGNvbnN0IHEgPSBxdWVyeShcbiAgICByZXZpZXdzQ29sbGVjdGlvbixcbiAgICB3aGVyZSgndXNlcklkJywgJz09JywgdXNlcklkKSxcbiAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICk7XG5cbiAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICByZXR1cm4gc25hcHNob3QuZG9jcy5tYXAoKGRvYykgPT4ge1xuICAgIHJldHVybiB7IGlkOiBkb2MuaWQsIC4uLmRvYy5kYXRhKCkgfSBhcyBSZXZpZXc7XG4gIH0pO1xufTtcblxuLy8gVXBkYXRlIGEgcmV2aWV3XG5leHBvcnQgY29uc3QgdXBkYXRlUmV2aWV3ID0gYXN5bmMgKFxuICByZXZpZXdJZDogc3RyaW5nLFxuICByZXZpZXdEYXRhOiB7XG4gICAgcmF0aW5nPzogbnVtYmVyO1xuICAgIGNvbW1lbnQ/OiBzdHJpbmc7XG4gICAgaW1hZ2VVcmw/OiBzdHJpbmc7XG4gIH0sXG4gIGltYWdlRmlsZT86IEZpbGVcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCByZXZpZXdSZWYgPSBkb2MoZGIsICdyZXZpZXdzJywgcmV2aWV3SWQpO1xuICBjb25zdCByZXZpZXdTbmFwID0gYXdhaXQgZ2V0RG9jKHJldmlld1JlZik7XG5cbiAgaWYgKCFyZXZpZXdTbmFwLmV4aXN0cygpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXZpZXcgZG9lcyBub3QgZXhpc3QnKTtcbiAgfVxuXG4gIC8vIFByZXBhcmUgdXBkYXRlZCBkYXRhXG4gIGNvbnN0IHVwZGF0ZURhdGEgPSB7IC4uLnJldmlld0RhdGEgfTtcblxuICAvLyBSZW1vdmUgdGhlIGltYWdlVXJsIGlmIGl0J3MgJ3BlbmRpbmctdXBsb2FkJyBhcyB3ZSdsbCByZXBsYWNlIGl0XG4gIGlmICh1cGRhdGVEYXRhLmltYWdlVXJsID09PSAncGVuZGluZy11cGxvYWQnKSB7XG4gICAgZGVsZXRlIHVwZGF0ZURhdGEuaW1hZ2VVcmw7XG4gIH1cblxuICAvLyBVcGxvYWQgaW1hZ2UgaWYgcHJvdmlkZWRcbiAgaWYgKGltYWdlRmlsZSkge1xuICAgIGNvbnN0IGltYWdlUmVmID0gcmVmKHN0b3JhZ2UsIGByZXZpZXdzLyR7dXVpZHY0KCl9YCk7XG4gICAgYXdhaXQgdXBsb2FkQnl0ZXMoaW1hZ2VSZWYsIGltYWdlRmlsZSk7XG4gICAgdXBkYXRlRGF0YS5pbWFnZVVybCA9IGF3YWl0IGdldERvd25sb2FkVVJMKGltYWdlUmVmKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSByZXZpZXcgd2l0aCBuZXcgZGF0YVxuICBhd2FpdCB1cGRhdGVEb2MocmV2aWV3UmVmLCB7XG4gICAgLi4udXBkYXRlRGF0YSxcbiAgICAvLyBSZXZpZXdzIHRoYXQgYXJlIGVkaXRlZCBuZWVkIHRvIGJlIGFwcHJvdmVkIGFnYWluXG4gICAgcGVuZGluZzogdHJ1ZSxcbiAgfSk7XG5cbiAgLy8gR2V0IHRoZSByZXZpZXcgYWZ0ZXIgdXBkYXRlIHRvIGFjY2VzcyB0aGUgc2VydmljZUlkXG4gIGNvbnN0IHVwZGF0ZWRSZXZpZXdTbmFwID0gYXdhaXQgZ2V0RG9jKHJldmlld1JlZik7XG4gIGNvbnN0IHVwZGF0ZWRSZXZpZXcgPSB1cGRhdGVkUmV2aWV3U25hcC5kYXRhKCkgYXMgUmV2aWV3O1xuXG4gIC8vIFVwZGF0ZSBzZXJ2aWNlIHJhdGluZyBhZnRlciBhIHJldmlldyBpcyB1cGRhdGVkXG4gIGF3YWl0IHVwZGF0ZVNlcnZpY2VSYXRpbmcodXBkYXRlZFJldmlldy5zZXJ2aWNlSWQpO1xufTtcblxuLy8gRGVsZXRlIGEgcmV2aWV3XG5leHBvcnQgY29uc3QgZGVsZXRlUmV2aWV3ID0gYXN5bmMgKHJldmlld0lkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgcmV2aWV3UmVmID0gZG9jKGRiLCAncmV2aWV3cycsIHJldmlld0lkKTtcbiAgY29uc3QgcmV2aWV3U25hcCA9IGF3YWl0IGdldERvYyhyZXZpZXdSZWYpO1xuXG4gIGlmICghcmV2aWV3U25hcC5leGlzdHMoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmV2aWV3IGRvZXMgbm90IGV4aXN0Jyk7XG4gIH1cblxuICBjb25zdCByZXZpZXcgPSByZXZpZXdTbmFwLmRhdGEoKSBhcyBSZXZpZXc7XG4gIGF3YWl0IGRlbGV0ZURvYyhyZXZpZXdSZWYpO1xuXG4gIC8vIFVwZGF0ZSBzZXJ2aWNlIHJhdGluZyBhZnRlciBhIHJldmlldyBpcyBkZWxldGVkXG4gIGF3YWl0IHVwZGF0ZVNlcnZpY2VSYXRpbmcocmV2aWV3LnNlcnZpY2VJZCk7XG59O1xuXG4vLyBHZXQgYSBzaW5nbGUgcmV2aWV3IGJ5IElEXG5leHBvcnQgY29uc3QgZ2V0UmV2aWV3QnlJZCA9IGFzeW5jIChcbiAgcmV2aWV3SWQ6IHN0cmluZ1xuKTogUHJvbWlzZTxSZXZpZXcgfCBudWxsPiA9PiB7XG4gIGNvbnN0IHJldmlld1JlZiA9IGRvYyhkYiwgJ3Jldmlld3MnLCByZXZpZXdJZCk7XG4gIGNvbnN0IHJldmlld1NuYXAgPSBhd2FpdCBnZXREb2MocmV2aWV3UmVmKTtcblxuICBpZiAoIXJldmlld1NuYXAuZXhpc3RzKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7IGlkOiByZXZpZXdJZCwgLi4ucmV2aWV3U25hcC5kYXRhKCkgfSBhcyBSZXZpZXc7XG59O1xuIl0sIm5hbWVzIjpbImNvbGxlY3Rpb24iLCJkb2MiLCJnZXREb2MiLCJnZXREb2NzIiwidXBkYXRlRG9jIiwiZGVsZXRlRG9jIiwicXVlcnkiLCJ3aGVyZSIsIm9yZGVyQnkiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJhZGREb2MiLCJyZWYiLCJ1cGxvYWRCeXRlcyIsImdldERvd25sb2FkVVJMIiwidjQiLCJ1dWlkdjQiLCJkYiIsInN0b3JhZ2UiLCJnZXRTZXJ2aWNlcyIsImluY2x1ZGVQZW5kaW5nIiwic2VydmljZXNDb2xsZWN0aW9uIiwiY29uc3RyYWludHMiLCJwdXNoIiwicSIsInNuYXBzaG90IiwiZG9jcyIsIm1hcCIsImlkIiwiZGF0YSIsImdldFNlcnZpY2VCeUlkIiwiZG9jUmVmIiwiZG9jU25hcCIsImV4aXN0cyIsImdldFJldmlld3NCeVNlcnZpY2VJZCIsInNlcnZpY2VJZCIsInNob3dQZW5kaW5nIiwicmV2aWV3c0NvbGxlY3Rpb24iLCJnZXRQZW5kaW5nUmV2aWV3cyIsImNyZWF0ZVJldmlldyIsInJldmlldyIsImltYWdlRmlsZSIsInJldmlld0RhdGEiLCJwZW5kaW5nIiwiY3JlYXRlZEF0IiwiaW1hZ2VSZWYiLCJpbWFnZVVybCIsInJldmlld1JlZiIsInVwZGF0ZVJldmlld1N0YXR1cyIsInJldmlld0lkIiwiYXBwcm92ZSIsInJldmlld1NuYXAiLCJFcnJvciIsInVwZGF0ZVNlcnZpY2VSYXRpbmciLCJhcHByb3ZlZFJldmlld3MiLCJsZW5ndGgiLCJ0b3RhbFJhdGluZyIsInJlZHVjZSIsInN1bSIsInJhdGluZyIsImF2ZXJhZ2VSYXRpbmciLCJzZXJ2aWNlUmVmIiwicmV2aWV3Q291bnQiLCJjcmVhdGVTZXJ2aWNlIiwic2VydmljZURhdGEiLCJuZXdTZXJ2aWNlIiwic2VhcmNoU2VydmljZXMiLCJzZWFyY2hUZXJtIiwidHJpbSIsInNlYXJjaFRlcm1Mb3dlciIsInRvTG93ZXJDYXNlIiwiZmlsdGVyZWRTZXJ2aWNlcyIsImZpbHRlciIsInNlcnZpY2UiLCJuYW1lIiwiaW5jbHVkZXMiLCJnZXRQZW5kaW5nU2VydmljZXMiLCJ1cGRhdGVTZXJ2aWNlU3RhdHVzIiwic2VydmljZVNuYXAiLCJnZXRSZXZpZXdzQnlVc2VySWQiLCJ1c2VySWQiLCJ1cGRhdGVSZXZpZXciLCJ1cGRhdGVEYXRhIiwidXBkYXRlZFJldmlld1NuYXAiLCJ1cGRhdGVkUmV2aWV3IiwiZGVsZXRlUmV2aWV3IiwiZ2V0UmV2aWV3QnlJZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/firestore.ts\n"));

/***/ })

});